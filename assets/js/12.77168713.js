(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{342:function(_,v,t){"use strict";t.r(v);var l=t(3),r=Object(l.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"https://resource.limeili.co/abstract/abstract%20(48).jpg",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"http缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http缺点"}},[_._v("#")]),_._v(" HTTP缺点")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("通信使用明文（不加密），内容可能被窃听"),t("br"),_._v("\n由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。\nHTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。")])]),_._v(" "),t("li",[t("p",[_._v("无法证明报文的完整性，所以可能遭篡改")])])]),_._v(" "),t("p",[_._v("没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的")]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("不验证通信方的身份，因此有可能遭遇伪装")])]),_._v(" "),t("h2",{attrs:{id:"https解决上述缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https解决上述缺点"}},[_._v("#")]),_._v(" HTTPS解决上述缺点")]),_._v(" "),t("p",[_._v("HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。\n通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。")]),_._v(" "),t("p",[_._v("HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：")]),_._v(" "),t("ol",[t("li",[_._v("散列函数 ，验证信息的完整性")]),_._v(" "),t("li",[_._v("对称加密，采用协商的密钥对数据加密")]),_._v(" "),t("li",[_._v("非对称加密，其利用非对称加密实现身份认证和密钥协商")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://resource.limeili.co/image/202007042222.png",alt:""}})]),_._v(" "),t("h3",{attrs:{id:"_1-解决内容可能被窃听的问题-加密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-解决内容可能被窃听的问题-加密"}},[_._v("#")]),_._v(" 1.解决内容可能被窃听的问题——加密")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("对称加密"),t("br"),_._v("\n这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了"),t("br"),_._v("\n以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥")])]),_._v(" "),t("li",[t("p",[_._v("非对称加密\n使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。"),t("br"),_._v("\n缺点:")])])]),_._v(" "),t("ul",[t("li",[_._v("公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；")]),_._v(" "),t("li",[_._v("使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率；")])]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("对称加密+非对称加密(HTTPS采用这种方式)\n使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，"),t("strong",[_._v("在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式")]),_._v("。"),t("br"),_._v("\n具体做法:发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制，但是首先要将B的公钥给A,这个过程没有保障中间人可以拦截，所以要确认B给A的公钥是真的："),t("strong",[_._v("数字证书")])])]),_._v(" "),t("h3",{attrs:{id:"_2-解决报文可能遭篡改问题-数字签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决报文可能遭篡改问题-数字签名"}},[_._v("#")]),_._v(" 2.解决报文可能遭篡改问题——数字签名")]),_._v(" "),t("p",[_._v("数字签名有两种功效：")]),_._v(" "),t("ul",[t("li",[_._v("能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。")]),_._v(" "),t("li",[_._v("数字签名能确定消息的完整性,证明数据是否未被篡改过。\n"),t("img",{attrs:{src:"https://resource.limeili.co/image/202007042336.png",alt:""}}),_._v("\n将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了\n"),t("img",{attrs:{src:"https://resource.limeili.co/image/202007042337.png",alt:""}})])]),_._v(" "),t("p",[_._v("接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。当然，这个过程的前提是B知道A的公钥，问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给A,或者说拿到的公钥如何证明是B的。此时就需要引入了证书颁发机构（Certificate Authority，简称CA），CA数量并不多，B客户端内置了所有受信任CA的证书。CA对A的公钥（和其他信息）数字签名后生成证书。")]),_._v(" "),t("h3",{attrs:{id:"_3-解决通信方身份可能被伪装的问题-数字证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-解决通信方身份可能被伪装的问题-数字证书"}},[_._v("#")]),_._v(" 3.解决通信方身份可能被伪装的问题——数字证书")]),_._v(" "),t("ul",[t("li",[_._v("服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;")]),_._v(" "),t("li",[_._v("CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;")]),_._v(" "),t("li",[_._v("如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个"),t("code",[_._v("签名")]),_._v("。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;")]),_._v(" "),t("li",[_._v("客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;")]),_._v(" "),t("li",[_._v("客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。")]),_._v(" "),t("li",[_._v("客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://resource.limeili.co/image/20200705134004.png",alt:""}}),_._v(" "),t("img",{attrs:{src:"",alt:""}})]),_._v(" "),t("h2",{attrs:{id:"https工作流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https工作流程"}},[_._v("#")]),_._v(" HTTPS工作流程")]),_._v(" "),t("ol",[t("li",[_._v("ClientHello")])]),_._v(" "),t("p",[_._v("首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。")]),_._v(" "),t("p",[_._v("在这一步，客户端主要向服务器发送以下信息：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。")])]),_._v(" "),t("li",[t("p",[_._v("客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。")])]),_._v(" "),t("li",[t("p",[_._v("客户端支持的密码套件列表，如 RSA 加密算法。")])])]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("SeverHello")])]),_._v(" "),t("p",[_._v("服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。")])]),_._v(" "),t("li",[t("p",[_._v("服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。")])]),_._v(" "),t("li",[t("p",[_._v("确认的密码套件列表，如 RSA 加密算法。")])]),_._v(" "),t("li",[t("p",[_._v("服务器的数字证书。")])])]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("客户端回应")])]),_._v(" "),t("p",[_._v("客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。")]),_._v(" "),t("p",[_._v("如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("一个随机数（pre-master key）。该随机数会被服务器公钥加密。")])]),_._v(" "),t("li",[t("p",[_._v("加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")])]),_._v(" "),t("li",[t("p",[_._v("客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。")])])]),_._v(" "),t("p",[_._v("上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。")]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[_._v("服务器的最后回应")])]),_._v(" "),t("p",[_._v("服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")])]),_._v(" "),t("li",[t("p",[_._v("服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。")])])]),_._v(" "),t("p",[_._v("至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。")]),_._v(" "),t("h2",{attrs:{id:"http与https的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http与https的区别"}},[_._v("#")]),_._v(" HTTP与HTTPS的区别")]),_._v(" "),t("ul",[t("li",[_._v("HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全")]),_._v(" "),t("li",[_._v("HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;")]),_._v(" "),t("li",[_._v("HTTPS需要用到SSL证书，而HTTP不用;")]),_._v(" "),t("li",[_._v("HTTPS标准端口443，HTTP标准端口80;")]),_._v(" "),t("li",[_._v("HTTPS基于传输层，HTTP基于应用层;  SSL位于应用层之下 传输层之上")]),_._v(" "),t("li",[_._v("HTTPS在浏览器显示绿色安全锁，HTTP没有显示;")])])])}),[],!1,null,null,null);v.default=r.exports}}]);